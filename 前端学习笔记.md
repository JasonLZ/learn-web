## 一. js基础

### 1.1 js介绍

---

​	**js分三个部分**:

> 1. ECMAScript 标准------js的基本语法
> 2. DOM-------Document Object Model 文档对象模型
> 3. BOM------Browser Object Model 浏览器对象模型

***js代码可以分三个地方写***

> 1. 在html的文件中，script的标签中js代码；
> 2. js代码可以在html的标签中写---内嵌
> 3. 在js文件中写js代码，并在html的页面中引入script的标签中的src="js的路径"。

***js代码的注意问题***

> 1. 在一对script的标签中有错误的js代码，那么该错误的代码后面的js代码不会执行；
> 2. 如果第一对的script标签中有错误，不会影响后面的script标签中的js代码执行；
> 3. script的标签中可以写什么内容：type="text/javascript"是标准写法或者写language="JavaScript"都可以；目前html页面中，type和language可以省略，因为html遵循h5标准；
> 4. 有可能出现这种情况：script标签中可能同时出现type和language的写法；
> 5. script标签在页面中可以出现多对；
> 6. script标签一般是放在body标签中的最后，有时会在head标签中；
> 7. 如果script标签是引入外部js文件的作用，那么这对标签中不要写任何的js代码，如果要写，重新写一对script标签，里面写代码；

***语法***

> 1. 变量的初始化：变量声明的同时赋值；存储一个对象：`var obj = new Object();`
>
> 2. 变量名规范：一般以字母、$符号或下划线开头；变量名一般小写。
>
> 3. ```js
>    var num = 100;
>    alert(num);//弹窗
>    console.log(num);//输出到控制台
>    console.log(var1,var2);
>                                                                         
>    //不要用小数去验证小数
>    var x = 0.1;
>    var y = 0.2;
>    var sum = x + y;//sum不等于0.3
>    console.log(sum==0.3);//false
>                                                                         
>    //不要用NaN验证是不是NaN,NaN与任何值都不相等，包括它本身
>    var num;
>    console.log(num+10);//NaN
>    console.log(num+10==NaN);//false  不是数字和不是数字不相等
>                                                                         
>    //使用isNaN()验证结果是不是NaN
>    var num;//变量声明了，但是没有赋值，结果是 undefined
>    var sum = num + 10;//NaN
>    console.log(isNaN(sum));//true 
>
>
>    ```
> 
> 4. js中的原始数据类型：number(数字类型，整数和小数),string,boolean,null,undefined,object
> 
> 5. NaN：not an number;
> 
> 6. typeof 变量名  或者 typeof(变量名)，这两种方式可以获取变量的数据类型。
> 
> 7. c语言中二进制0b或者0B开头，八进制0开头，十六进制0x开头
> 
> 8. 数字类型：number类型，无论整数小数都是数字类型。字符串可以使用单引号也可以使用双引号。
> 
> 9. `console.log(Number.MAX_VALUE);console.log(Number.MIN_VALUE);`数字类型的最大值与最下值
> 
> 10. 使用+可以使多个字符串拼接。只要有一个是字符串，其他是数字，那么结果也是拼接；如果一个是字符串，另一个不是字符串，使用-号，此时会进行计算。
> 
> ```js
> ////////////////////////////
> var str1 = "10";
> var str2 = "20";
> console.log(str1+str2);//1020
> 
> var str1 = "10";
> var str2 = 20;
> console.log(str1 + str2);//1020
> 
> var str1 = "10";
> var str2 = 5;
> console.log(str1 - str2);//5
>    ```
>
> 11. ```js
>     //其他类型转数字类型：三种方式
>     //1.parseInt();//转整数
>     console.log(parseInt("10"));//10
>     parseInt("10fdsaf");//10
>     parseInt("g10");//NaN
>     parseInt("1fds0");//1
>     parseInt("10.98");//10
>     parseInt("10.98fadsf");//10
>                                                                                                 
>     //2.parseFloat()//转小数
>     console.log(parseFloat("10"));//10
>     parseFloat("10fdsaf");//10
>     parseFloat("g10");//NaN
>     parseFloat("1fds0");//1
>     parseFloat("10.98");//10.98
>     parseFloat("10.98fadsf");//10.98
>     //3.Number();//转数字
>     console.log(Number("10"));//10
>     Number("10fdsaf");//NaN
>     Number("g10");//NaN
>     Number("1fds0");//NaN
>     Number("10.98");//10.98
>     Number("10.98fadsf");//NaN
>                                                                                                 
>     //Number()方式更严格
>
>
>     //其他类型转字符串类型
>     //1		.toString()
>     var num = 10;
>     console.log(num.toString());//控制台10显示黑色，说明是字符串类型
>                                                                                                 
>     //2 	String();
>     var num1 = 20;
>     console.log(String(num1));
>
>
>     //其他类型转布尔类型
>     //1. Boolean(值);
>     console.log(Boolean(1));//true
>     console.log(Boolean(0));//false
>     console.log(Boolean("哈哈"));//true
>     console.log(Boolean(""));//false
>     console.log(Boolean(null));//false
>     console.log(Boolean(undefined));//false
>
>
>     var str = 10;
>     console.log(-str);//输出-10
>                                                                                                 
>     // ==(不严格)与===   !=(不严格)与!==
>     var str = "5";
>     var num = 5;
>     console.log(str==num);//true
>     console.log(str===num);//false
>     == 只进行值比较，===类型和值同时比较相等
>     ```
>
> 12.流程控制 
>
> ~~~js
> //提示用户输入年龄
> var age = prompt("请您输入年龄：");//弹框，并且有输入，输入的内容存入age
> console.log(age);//最终的结果是字符串类型
> var age = parseInt(prompt("请您输入年龄："));//age是数字类型
> 
> ~~~
>
> ```js
> //switch-case语句，default后的break可以省略。switch中的值与case比较时，是三个等号比较===;即
> var num = "10";
> switch(num) {
> 	case 10:
> 		console.log("数字的10");
> 		break;
> 	case "10":
> 		console.log("字符串的10");
> 		break;
> }
> //输出了字符串的10
> ```
>
> 如果有多个分支，是针对范围的判断，一般用if-else if，如果有多个分支是针对具体的值的判断，一般用switch-case语句。
>
> ```js
> var userName = prompt("请输入账号");
> var userPwd = prompt("请输入密码");
> while(userName != "admin" || userPwd != "123") {
>     userName = prompt("请输入账号");
>     userPwd = prompt("请输入密码");
> }
> console.log("登陆成功");//上面输对才会跳出循环，不必有计数器.
> 
> 
> document.write("haha");//内容输入到页面,可以嵌入html
> document.write("<a href='http://www.baidu.com'>百度</a>");
> alert();//弹框
> console.log();//输出在控制台
> ```
>
> 调试：f12->source，然后双击文件，某一行前面点一下就是添加断点，然后f5刷新看代码
>
> 13 数组和函数
>
> > 数组的定义:
> >
> > 1. 通过构造函数创建数组
> >
> >    var 数组名 = new Array(长度);
> >
> >    var array = new Array(5);//5为数组长度
> >
> > 2. 通过字面量的方式创建数组。
> >
> >    var 数组名 = [];
> >
> >    var array = [];
> >
> > 3. 无论构造函数的方式还是字面量的方式，定义的数组，如果有长度，那么默认是undefined。
> >
> > ```js
> > var arr1 = new Array();//构造函数的方式----空数组
> > var arr2 = new Array(5);//数组长度是5，每个元素都是undefined。
> > var arr = new Array(10, 20, 30);//存了三个数
> > console.log(arr.length);
> > ```
> >
> > 4.数组中存的数据，类型可以不一样。数组长度可以改变
> >
> > ```js
> > var arr1 = new Array();//空数组
> > var arr2 = new Array(5);//长度为5的数组，每个数据的值是undefined
> > var arr3 = new Array(1,2,3,4,5);//长度为5的数组
> > var arr4 = [];//空数组
> > var arr5 = [1,2,3];//长度为3的数组
> > var arr6 = ["red", "blue", "green", 1, true];//数组中元素的值的类型可以不一样
> > 
> > var arr7 = [];//数组长度为0
> > //设置数组的元素的值
> > arr7[0] = 10;//数组长度为1
> > arr7[1] = 20;//数组长度为2
> > ```
> >
> > 5.函数
> >
> > ```js
> > 函数的定义
> > 语法：
> > function 函数名字(){
> >     函数体;
> > }
> > 函数的调用:
> > 函数名();
> > 
> > //求三个数字的最大值
> > function max3() {
> >     var x, y, z;
> >     var max = x > y ? (x>z?x:z):(y>z?y:z);
> >     console.log(max);
> > }
> > max3();//调用
> > 
> > //函数形参不需要加var
> > function sum(x, y) {
> >     var sum = x + y;
> >     console.log(sum);
> > }
> > sum(10,20);
> > //返回值
> > function getSum(x,y) {
> >     var sum = x + y;
> >     return sum;//把和返回
> > }
> > var res = getSum(10,20);
> > console.log(res+10);
> > ```
> >
> > * 函数一旦重名，后面的会把前面的函数覆盖。函数在定义的时候小括号里的变量叫形参，函数在调用的时候小括号里传入的值叫实参。形参的个数可以和实参的个数不一致。
> >
> > * 函数没有返回值，但是在调用的时候接收了，那么结果就是undefined。变量声明了，没有赋值，结果也是undefined。
> >
> >   ```js
> >   function f1(x,y) {
> >       var sum = x+y;
> >   }
> >   var res = f1(10,20);
> >   console.log(res);//undefine
> >
> >   function f1() {
> >       //获取的是函数在调用的时候，传入的参数数量
> >       console.log(arguments.length);
> >       //使用arguments对象可以获取传入的每个参数的值
> >       console.log(arguments);
> >   }
> >   f1(10,20,30);//调用
> >
> >   function f2() {
> >       //arguments 可以当数组使用，伪数组
> >       var sum = 0;
> >       for(var i = 0; i<arguments.length;i++) {
> >           sum += arguments[i];
> >       }
> >       return sum;
> >   }
> >   console.log(f2(10,20,30));
> >   ```
> >
> > * 匿名函数：没有函数名；函数的另一种定义方式：函数表达式：即把一个函数给一个变量，此时形成了函数表达式
> >
> >   ```js
> >   //匿名函数不能直接调用
> >   //以下是函数表达式
> >   var f2 = function () {
> >       console.log("haha");
> >   };
> >   f2();//调用
> >   ```
> >
> > * ```js
> >   //函数声明
> >   function f1() {
> >       console.log("sf");
> >   }
> >   f1();//输出fasdf
> >   function f1() {
> >       console.log("fasdf");
> >   }
> >   f1();//输出fasdf
> >   //后面会把前面覆盖，两次f1调用都是输出后面的f1内容。
> >   /////////////////////////
> >                                                       
> >   //函数表达式
> >   var f2 = function () {
> >       console.log("haha");
> >   };
> >   f2();//输出haha
> >   f2 = function () {
> >       console.log("lala");
> >   };
> >   f2();//输出lala
> >                                                       
> >   //函数的自调用,没有名字，声明的同时，直接调用
> >   //一次性的
> >   (function () {console.log("1231");})();
> >   (function () {console.log("qwer");})();
> >   //匿名函数的好处是不会冲突
> >                                                       
> >   //如何获取某个变量的类型？typeof
> >   function f1() {
> >       console.log("func");
> >   }
> >   console.log(typeof f1);//输出为function类型
> >   //函数也有数据类型，是function类型的
> >                                                       
> >   //函数作为参数
> >   function f1(fn) {
> >       fn();//函数调用--说明fn这个变量中存储的是一个函数
> >   }
> >                                                       
> >   function f2() {
> >       console.log("ai");
> >   }
> >   f1(f2);
> >   //只要是看到一个函数作为参数使用了，那就是回调函数。
> >                                                       
> >   //函数作为返回值使用
> >   function f1() {
> >       console.log("f1函数被调用了");
> >       return function () {
> >           console.log("这是一个函数");
> >       }
> >   }
> >   var ff = f1();//调用
> >   //ff就是一个函数了
> >   ff();//调用
> >   ```
> >
> > * js没有块级作用域一说，就是{}中的变量，外面也能访问。全局变量：变量是使用var声明的，那么这个变量就是全局变量，可以在页面的任何位置使用。局部变量：在函数内部定义的变量，是局部变量，外面不能使用。除了函数以外，其他的任何位置定义的变量都是全局变量。全局变量，如果页面不关闭，那么就不会释放，就会占空间，消耗内存。
> >
> > * 隐式全局变量：声明的变量没有var，就叫隐式全局变量。
> >
> >   ```js
> >   function f1() {
> >       number = 1000;//没有var声明，是隐式全局变量
> >   }
> >   console.log(number);//外面也能访问
> >
> >   function f2() {
> >       var number = 100;//外面不能访问，是局部变量
> >   }
> >   ```
> >
> > * 全局变量是不能被删除的（delete），隐式全局变量是可以被删除的；即定义变量使用var是不会被删除的，没有var是可以删除的。
> >
> > * 变量声明了没有赋值，是undefined
> >
> > * 预解析：提前解析代码；会把变量的声明提前，也会把函数的声明提前。（提前到当前所在的作用域的最上面），就是说你现在调用的变量在之后才定义的也不会报错。
> >
> >   ```js
> >   f1();//调用  输出undefined
> >   var num = 20;
> >   function f1() {
> >       console.log(num);
> >   }
> >   //函数声明和变量声明都提前了，其实是下面的样子，所以输出undefined
> >   var num;
> >   function f1() {
> >       console.log(num);
> >   }
> >   f1();
> >   
> >   ```
> >
> > * 预解析中，变量的提升，只会在当前的作用域中提升，提前到当前的作用域的最上面；函数中的变量只会提前到函数的作用域中的最前面，不会出去；预解析会分段（多对的script标签中函数重名，预解析的时候不会冲突，互不影响）
> >
> > ```js
> > function f1() {
> >     console.log(sum);//undefined
> >     var num = 10;
> > }
> > f1();
> > console.log(num);//报错
> > ```
> >
> > * 预解析：js代码的执行是由浏览器中的js解析器来执行的，js解析器执行js代码的时候，分为两个过程：预解析过程和代码执行过程。
> > * 预解析过程：1. 把变量的声明提升到当前作用域的最前面，只会提升声明，不会提升赋值；2. 把函数的声明提升到当前作用域的最前面，只会提升声明，不会提升调用；3.先提升var，在提升function。
> >
> > ```js
> > f1();
> > console.log(c);//9
> > console.log(b);//9
> > console.log(a);//报错
> > function f1() {
> >     var a = b = c = 9;
> >     console.log(a);//9
> >     console.log(b);//9
> >     console.log(c);//9
> > }
> > //上面的代码相当于是
> > function f1() {
> >     var a;
> >     a = 9;
> >     b = 9;//隐式全局变量
> >     c = 9;//隐式全局变量
> >     console.log(a);
> >     console.log(b);
> >     console.log(c);
> > }
> > f1();
> > console.log(c);
> > console.log(b);
> > console.log(a);
> > 
> > 
> > **********************
> > f1();
> > var f1 = function() {
> >     console.log(a);
> >     var a = 10;
> > };
> > //以上代码报错，变量f1会提前，无法调用
> > //相当于下面这样
> > var f1;
> > f1();
> > f1 = function () {
> >     console.log(a);
> >     var a = 10;
> > };
> > ```
>
> 14. 对象
>
> * 创建对象的三种方式：
>
>   1. 调用系统的构造函数创建对象；
>
>      var 变量名 = new Object(); Object是系统的构造函数
>
>   2. 自定义构造函数创建对象； 
>
>   3. 字面量的方式创建对象。 
>
> ```js
> //1.
> var obj = new Object();
> //添加属性: 对象.名字=值;
> obj.name = "xiaoming";
> obj.age = 30;
> //添加方法: 对象.名字=函数;
> obj.eat = function(){
>     console.log("hah");
> }
> obj.eat();//调用
> ```
>
> * 如何获取该变量(对象)是不是属于什么类型的？
>
>   语法：
>
>   变量 instanceof 类型的名字    --------布尔类型，true就是这种类型 instance例子，实例
>
>   `console.log(obj instanceof Object);//true`
>
>   在当前的对象的方法中，可以使用this关键字代表当前的对象
>
> * 自定义构造函数创建对象
>
>   ```js
>   /*
>   	1. 在内存中开辟（申请一块空闲的空间）空间，存储创建的新的对象
>   	2. 把this设置为当前的对象
>   	3. 设置对象的属性和方法的值
>   	4. 把this这个对象返回
>   */
>   function Person(name, age) {//构造函数
>       this.name = name;
>       this.age = age;
>       this.sayHi = function() {
>           console.log("wojiao"+this.name+"年龄"+this.age);
>       };
>   }
>
>   var obj = new Person("lal",10);
>   obj.sayHi();
>   function f1() {
>       //函数
>   }
>   ```
>
>   函数和构造函数的区别：首字母是不是大写
>
> * 字面量的方式创建对象 
>
>   ```js
>   var obj = {};//空对象
>   obj.name = "fd";
>   obj.age = 10;
>   obj.sayHi = function() {
>       console.log("dsf");
>   }
>   obj.sayHi();
>   //优化写法
>   var obj2 = {
>       name:"dfs",
>       age:20,
>       sayHi:function() {
>           console.log("我是"+this.name);
>       },
>       eat:function() {
>           console.log("sdf");
>       }
>   }
>   obj2.sayHi();
>   obj2.eat();
>   ```
>
>   字面量创建对象的缺陷：一次性的对象，写死了
>
>   js是一门动态类型的语言：
>
>   1. 代码（变量）只有执行到这个位置的时候，才知道这个变量中到底存储的是什么，如果是对象，就有对象的属性和方法，如果是变量就是变量的作用。
>   2. 对象没有什么，只要点.了，通过点语法，那么就可以为对象添加属性或者方法。
>
>   ```js
>   //访问属性另一种写法
>   function Person(name, age) {
>       this.name = name;
>       this.age = age;
>       this.play = function() {
>           console.log("saf");
>       };
>   }
>   var obj = new Person("fdas",20);
>   //obj.name = "we";
>   obj["name"] = "haha";
>   console.log(obj["name"]);
>   //console.log(obj.name);
>   //obj.play();
>   obj["play"]();
>   //其实就是把点换成中括号，里面加双引号
>   ```
>
> * json数据格式
>
> ```js
> //对象：有属性和方法，特指某个事物
> //对象:一组无序属性的集合的键值对，属性的值可以是任意的类型
> //json格式的数据：一般都是成对的，是键值对
> //json也是一个对象，数据都是成对的，一般json格式的数据无论是键还是值都是用双引号括起来的。
> 
> var json = {
>   "name":"小明",
>   "age":"10",
>   "sex":"nan"；
> };
> var key = "height";
> console.log(json[key]);//undefined
> //可以通过for-in循环遍历
> for(var key in json) {
>     console.log(key);//json对象中的属性的名字
>     console.log(json.key);//undefined 意思是给这个对象添加了一个属性key  点.的用法
>     console.log(json[key]);//正确输出键对应的值
>     //注意点.和[]的用法区别
> }
> //对象中确实有这个属性  对象.属性的名字  或者对象[属性名字]进行访问
> //没有这个属性不能用点.，用点相当于添加了一个属性，且是undefined
> 
> 
> //key是一个变量，这个变量中存储的是该对象的所有属性的名字
> for(var key in json) {
>     console.log(key+ "======"+json[key]);//不能用点.
> }
> ```
>
> ![image-20220912224457328](C:\Users\JasonLz\AppData\Roaming\Typora\typora-user-images\image-20220912224457328.png)
>
> ![image-20220912225907695](C:\Users\JasonLz\AppData\Roaming\Typora\typora-user-images\image-20220912225907695.png)
>
> 值传递和引用传递，联想c语言指针
>
> var num = 10;//值类型，值在栈上
>
> var obj = {};//复杂类型，对象在堆，地址（引用）在栈
>
> 值类型之间传递，传递的是值，引用类型之间传递，传递的是地址（引用）；值类型作为函数的参数，传递的是值，引用类型作为函数的参数，传递的是地址（其实传的也是值，只不过这个值是一个地址）
>
> ![image-20220912231319750](C:\Users\JasonLz\AppData\Roaming\Typora\typora-user-images\image-20220912231319750.png)
>
> js学习中的三种对象：
>
> 1. 内置对象---------js系统自带的对象；
> 2. 自定义对象-------------自己定义的构造函数创建的对象
> 3. 浏览器对象---------BOM

## 对象

1. MDN在线帮助文档；
2. 实例对象：通过构造函数创建出来，实例化的对象；
3. 静态对象：不需要创建，直接就是一个对象，方法（静态方法）直接通过这个对象名调用。
4. 实例方法必须通过实例对象调用；静态方法必须通过大写的对象调用。Math.PI

```js
console.log(Math.abs(null));//输出0
Math.ceil(x);//向上取整
Math.floor(x);//向下取整

//例子：自定义一个对象，实现系统的max方法
function MyMath() {
    this.getMax = function() {
        var max = arguments[0];
        for(var i = 0;i<arguments.length;i++){
            if(max < arguments[i]) {
                max = arguments[i];
            }
        }
        return max;
    };
}
//实例对象
var mt = new MyMath();
var result = mt.getMax(10,20,50);
console.log(result);

//Date
var dt = new Date();
console.log(dt);
console.log(dt.toString());
console.log(dt.valueOf());//毫秒数
```

### String对象

​	string ->字符串类型---基本类型；String ->字符串类型---引用类型；js中无论是单引号的还是双引号的都是字符串。

String是一个对象；字符串可以看成是字符组成的数组，但是js中没有字符类型；字符串可以看成是数组，所以可以通过for循环进行遍历。

字符串特性：不可变性，字符串的值是不能改变。

```js
var str = "hello";
str[1] = "W";//字符串可以通过索引访问其中的某个值，但是可以访问---读取--只读,但无法改变
console.log(str);//还是hello

var str = "dfasfa";
str = "fasedsfw";//重新赋值
console.log(str);//输出第二个
//这里字符串的值之所以看起来是改变的，其实是因为指向改变了，并不是真正的值改变了。


var str = String.fromCharCode(107,108,109);
console.log(str);//输出klm


字符串的常用属性：
.charAt(index),返回值指定索引位置的字符串
.fromCharCode(数字值，可以是多个参数),返回ascii码对应的值
.concat(字符串1,字符串2,字符串3)；拼接
.indexOf();
.lastIndexOf();
.replace();
.slice(begin,end);//[begin,end)
.split("要干掉的字符串"，切割后留下的个数);//返回的是数组Array
.substr(开始的位置，个数);
.substring(开始的索引，结束的索引);
.toLocaleLowerCase();//转小写
.toLowerCase();//转小写
.toLocaleUpperCase();
.toUpperCase();
.trim();//去掉字符串两端的空格


```

### Array

```js
var arr1 = new Array();//构造函数
var arr2 = [];//字面量的方式

//变量是不是数组类型：两种
//1. instanceof
var obj = [];
console.log(obj instanceof Array);
//2.数组的方法
console.log(Array.isArray(obj));

/*
数组的方法
.isArray();
.concat();
.every(callback, thisArg);返回值是布尔类型，函数作为参数，函数中有三个参数，第一个是元素的值，第二个是参数是索引值，第三个参数是原来的数组
如果这个数组中的每个元素的值都符合条件，最后才返回的是true
.filter();
.shift();
.unshift();
.push();
.pop();
.forEach();//遍历数组
.indexOf(元素值);//返回的是索引，没有则是-1
.join();
.map();
.reverse();
.sort();
.slice();
.splice();
*/
var arr=["adsf","asdfwe","sdf","wedsfwe"];
arr.every(function(ele, index) {
    return ele.length>4;//false
});
```





实例方法：必须通过new的方式创建的对象（实例化对象）来调用的方法；

静态方法：直接通过大写的构造函数的名字调用的方法

### 基本包装类型

基本包装类型：本身是基本类型，但是在执行代码的过程中，如果这种类型的变量调用了属性或者方法，那么这种类型就不再是基本类型了，而是基本包装类型，这个变量也不是普通的变量了，而是基本包装类型对象。

基本类型：string number boolean

* 普通变量不能直接调用属性或者方法；
* 对象可以直接调用属性和方法；

```js
//如果是  对象&&true，那么结果是true
//如果是 true&&对象，那么结果是对象
//就是短路
var flag = new Boolean(false);
var res = true&&flag;
console.log(res);//结果是对象

var num = 10;
var num2 = Number("10");//注意这是转换，没有new，是基本类型
var num3 = new Number("10");//基本包装类型

var str = "hello";
str = str.replace("ll","HH");
console.log(str);

//上面的代码，其实浏览器做了下面的事
var str = new String("hello");
str = str.replace("ll","HH");
console.log(str);
str=null; 
```

## 二.  WEB API

js分三个部分：ECMAScript标准，js的基本语法；DOM:Documnet Object Model 文档对象模型，操作页面的元素；BOM：Browser Object Model浏览器对象模型，操作的是浏览器 。

文档：把一个html文件看成是一个文档，把这个文档看成是一个对象；xml文件也可以看成一个文档。

html：展示信息，展示数据的；XML：侧重于存储数据。html文件看成是一个文档，这个文档看成是一个对象，文档中的所有标签都可以看成是一个对象。

页面中的每个标签都是一个元素（element），每个元素都可以看成是一个对象，标签可以嵌套，标签中有标签，元素中有元素。html页面中都有一个根标签-html，也叫根元素；页面中有一个根元素（标签-html）,里面有很多的元素（标签/对象）。

文档：一个网页就是一个文档；元素(element)：页面中的所有标签都是元素，元素可以看成是对象。节点(node)：页面中所有的内容都是节点，内容包括：标签，属性，文本，注释等。所以说节点范围大于元素；属性：标签的属性。

页面就是文档-document，文档中有根元素：html；html里有head，body等，body里又有其他的标签。由文档及文档中的所有的元素（标签）组成的一个树形结构图，叫树状图（DOM树）

```html
<!DOCTYPE html>
<html lang="en">
<head>
</head>
<body>
<input type="button" value="显示效果" id="btn"/>
<!--<input type="button" value="显示效果" onclick="alert('我被点了')" />第一个版本-->

    
<!--第二个版本-->
<script>
	function f1(){
        alert("dasf");
    }    
</script>
<input type="button" value="显示效果" onclick="f1()"/>
    
<!--开始分离html和js-->
<input type="button" value="开始分离代码" id="btn"/>第三个版本
<script>
	function f2(){
        alert("开始分离html和js代码");
        //html标签中的id属性中存储的值是唯一的，
        //id属性像人的身份证号码一样，不能重复，页面中唯一的标识
        //从文档中找到id值为btn的这个标签（元素）
        //documnet.getElementById("id属性的值")----返回的是一个元素对象
        var btnObj = document.getElementById("btn");
        //为按钮注册点击事件
        btnObj.onclick=f2;//注意函数f2不加括号
    }    
</script>
    
<!--最终版-->
<input type="button" value="最终版" id="btn1"/>
<script>
    //先有按钮，才能获取，获取之后才能注册事件，把script脚本放下面
    //根据id属性的值从文档中获取这个元素
    var btnObj1 = document.getElementById("btn1");
    //为当前的这个按钮元素（对象），注册点击事件，添加事件处理函数（匿名函数）
    btnObj.onclick=function(){
        alert("hah");//响应
    };
  
</script>  
<input type="button" value="最终版" id="btn2"/>
<script>
    document.getElementById("btn2").onclick=function(){//和上面一样，最终版
        alert("haha");
    };
</script>   
    
    
//案例一   点击按钮显示图片及设置宽和高
<input type = "button" value = "显示图片" id = "btn"/>
<img src="" alt="" id="im" />//f12 看elements的变化
<script>
    var btnObj = document.getElementById("btn");
    btnObj.onclick=function() {
        var imObj = document.getElementById("im");
        imObj.src="images/demo.jpg";
        imObj.width="300";
        imObj.height="400";
    };
</script>

//案例二 点击按钮设置p标签的文本内容
<input type="button" value="设置p的内容" id="btn" />
<p id="p1">我是一个p标签</p>
<script>
    //凡是成对的标签，中间的文本内容，设置的时候，都使用innerText这个属性的方式
    document.getElementById("btn").onclick=function() {
        document.getElementById("p1").innerText="这是一个p";
    };
</script>

//案例三	点击按钮修改a标签的地址和热点文字
<input type="button" value="显示效果" id="btn" />
<a id="ak" href="https://www.jiumodiary.com/">鸠摩搜书</a>
<script>
	document.getElementById("btn").onclick = function() {
        //document.getElementById("ak").href="https://www.baidu.com";
        //document.getElementById("ak").innerText="百度";
        var aObj = document.getElementById("ak");
        aObj.href = "https://www.baidu.com";
        aObj.innerText = "百度";
    };
</script>
    
//案例四	点击按钮设置所有的p标签内容的文字内容
<input type="button" value="显示效果" id="btn" />
<div id="dv1">
    <p>lal</p>
    <p>lal</p>
    <p>lal</p>
    <p>lal</p>
</div>
<div id="dv2">
    <p>lal</p>
    <p>lal</p>
    <p>lal</p>
    <p>lal</p>
</div>
<script>
    //document.getElementsByTagName("标签的名字");//返回的是一个伪数组
    document.getElementById("btn").onclick=function() {
        //var pObjs = document.getElementsByTagName("p");//这个是把所有的p标签内容都改了
        var pObjs = document.getElementById("dv1").getElementsByTagName("p");//只改dv1里面的
        for(var i = 0;i<pObjs.length;++i) {
            pObjs[i].innerText="我们都是p";
        }
    }
</script>
//案例五	修改图片的alt和title属性
<input type="button" value="显示效果" id="btn" />
<img src="images/de.jpg" alt="haha" title="gaga" />
<script>
	document.getElementById("btn").onclick = function(){
      //返回的是一个伪数组
   	  var imgObjs document.getElementsByTagName("img");
        imgObjs[0].alt="改了";
        imgObjs[0].title = "现实";
    };    
</script>
//案例六	点击按钮修改多个文本框的值
<input type="button" value="修改文本框的值" id="btn"/><br/>
<input type="text" value=""><br/>
<input type="text" value=""><br/>
<input type="text" value=""><br/>
<input type="text" value=""><br/>
<input type="text" value=""><br/>
<script>
	document.getElementById("btn").onclick=function() {
        var inputs = document.getElementsByTagName("input");
        for(var i = 0;i<inputs.length;++i) {
            if(inputs[i].type!="button") {
                inputs[i].value="haha";
            }
        }
    }    
</script>
    
//案例七	点击按钮修改value属性
<input type="button" value="按钮" id="btn"/>
<script>
    //在某个元素的事件中，自己的事件中的this就是当前的这个元素对象
	var btnObj = document.getElementById("btn");
    btnObj.onclick = function(){
        this.value = "changed";//等价于btnObj.value
        this.type = "text";
        this.id = "btn2";
    }
</script>

//案例八	按钮的排他功能
<input type="button" value="关闭" />
<input type="button" value="关闭" />
<input type="button" value="关闭" />
<input type="button" value="关闭" />
<script>
    var btnObjs = document.getElementsByTagName("input");
    for(var i = 0;i<btnObjs.length;i++) {
        btnObjs[i].onclick = function() {
            for(var j = 0;j<btnObjs.length;j++) {//先把所有的设置成默认，然后在改。
                btnObjs[j].value = "关闭";
            }
            this.value = "开启";
            //btnObjs[i].value = "开启";//错误写法
            //因为for循环是在页面加载的时候，执行完毕了
            //事件是在触发的时候执行的。
        }；
    }
</script>
    
//案例九 点击图片修改路径
<a id="ak" href="images/1.jpg"><img src="images/1-small.jpg" alt="" id="im"></a>
<script>
	document.getElementById("im").onclick = function() {
        this.src = document.getElementById("ak").href;
        return false;//加上这句，路径就换不成功了
    }    
</script>

//案例十 点击按钮切换图片
<input type="button" value="显示大图" id="btn"/>
<img src="images/1-small.jpg" alt="" id="im">
<script>
	function my$(id) {
        return document.getElementById(id);
    }   
    my$("btn").onclick=function() {
        my$("im").src="images/1.jpg";
    };
</script>
    
//案例十一	点击按钮选择性别和兴趣(radio单选，checkbox多选)
<input type="button" value="修改性别" id="btn1">
<input type="radio" value="1" name="sex" />男
//<input type="radio" value="2" name="sex" checked="checked" />女
<input type="radio" value="2" name="sex" id="rad1" />女
<input type="radio" value="3" name="sex" />保密
<script>
	function my$(id) {
        return document.getElementById(id);
    }    
    //规律:在表单标签中，如果属性和值只有一个，并且值是这个属性本身（例如上面的checked属性）,
    //那么在写js代码dom操作的时候，这个属性值，是布尔类型就可以了
    my$("btn1").onclick = function() {
        my$("rad1").checked = true;
    }; 
</script>
<br />
<input type="button" value="选择兴趣" id="btn2" />dsaf
<input type="checkbox" value="1" name="xingqu" />sdafwe
<input type="checkbox" value="2" name="xingqu" />sdfx
<input type="checkbox" value="3" name="xingqu" id="ck1" />dsafwe
<input type="checkbox" value="4" name="xingqu" />sadfwe
<input type="checkbox" value="5" name="xingqu" />sadf
<input type="checkbox" value="6" name="xingqu" id="ck2" />xfsdf
    
<script>
	my$("btn2").onclick=function() {
        my$("ck1").checked=true;
        my$("ck2").checked=true;
    };    
</script>
    
//案例十二	选择下拉框和文本域的相关属性设置
<input type="button" value="点菜" id="btn" />
<select name="" id="ss">
    <option value="1">榴莲</option>
    <option value="2">臭豆腐</option>
    <!--<option value="3" selected="selected">榴莲</option>//默认选中榴莲-->
    <option value="3" id="op1">榴莲</option>
    <option value="4">西红柿</option>
    <option value="5">肉</option>
</select>
<script src="common.js"></script>
<script>
    my$("btn").onclick = function() {
        my$("op1").selected = true;
    }
</script>
//disabled是禁用，readonly是只读    
<textarea name="" id="tt" cols="30" rows="10" readonly="readonly" <!--disabled="disabled"--> >
    注册用户的协议：
    
    啦啦啦啦啦
    
</textarea>
<input type="button" value="注册" id="btn2" disabled />
<script>
    //html中属性和值是自己的，并且只有一个的，可以只写这个属性，不用赋值
    my$("btn2").onclick=function() {
        //value方式，页面改了，f12看也改了，innerText方式，f12看没有变
        my$("tt").value="gaga";//推荐这种写法,因为看成了是表单的标签
        //my$("tt").innerText="haha";        
    };
</script>
    
    
//案例十三	点击按钮设置div样式
<input type="button" value="设置样式" id="btn" />
    //<div id="dv" style="width:200px;height:100px;background-color:red"></div>
    <div id="dv"></div>
    <script>
        //凡是css中这个属性是多个单词的写法，在js代码中DOM操作的时候，把-干掉，后面的单词首字母大写即可.
    	my$("btn").onclick = function() {
            my$("dv").style.width="300px";
            my$("dv").style.heigth = "100px";
            my$("dv").style.backgroundColor = "hotpink";
        };
    </script>
    
//案例十四	div的显示和隐藏通过类样式实现
    //在head标签里写style
    <style>
        div {
            width:300px;
            height:200px;
            background-color:yellow;
            border:2px solid red;
        }
        .cls{
            width:300px;
            height:200px;
            background-color:yellow;
            border:2px solid red;
        }
    </style>
    <input type="button" value="设置样式" id="btn" />
    //<div class="cls" id="dv"></div>
    <div id="dv"></div>
    <script src="common.js"></script>
    <script>
    	//设置div的样式
        my$("btn").onclick = function(){
            //var dvObj = my$("dv");
            //dvObj.style.width = "300px";
            //dvObj.style.height = "300px";
            //dvObj.style.backgroundColor = "yellow";
            //dvObj.style.border = "10px solid red";
            
            //在js代码中DOM操作的时候，设置元素的类样式，不用class关键字，
            //应该使用 className
            //my$("dv").class="cls";//不能这样写,js中class是关键字，
            //为了和上面的属性class区分开，用className
            my$("dv").className = "cls";
        }
    </script>
    
//案例十五 开关灯
    <head>
    <style>
        .cls{
            background-color:black;
        }
    </style>
    </head>
    <body id="bd">
        <input type="button" value="开/关灯" id="btn" />
        <script>
        	my$("btn").onclick = function() {
                //获取body标签
                document.body.className = document.body.className !="cls"?"cls":"";
            };
        </script>
    </body>
    
</body>
</html> 
```

操作表单标签的属性：name value type checked selected disabled readonly

基本标签没有name属性，表单标签才有。

> 元素:element:页面中的标签
>
> 节点：Node:页面中所有的内容，标签，属性，文本
>
> 根元素：html标签
>
> 页面中的顶级对象：document

案例

```html
案例一：改变列表背景色
<input type="button" value="变色" id="btn" />
<ul id="uu">
    <li>卡卡西</li>
    <li>大蛇丸</li>
    <li>鸣人</li>
    <li>佐助</li>
    <li>雏田</li>
</ul>
<script>
	document.getElementById("btn").onclick = function() {
        document.getElementById("uu").style.backgroundColor="red";
    };
</script>
案例二：阻止超链接默认跳转
//阻止超链接的默认跳转 :return false
<a href="http://www.baidu.com" onclick="alert('被点了');return false">百度</a>//第一种写法

//第二种写法
<script>
	function f1() {
        alert("被点了");
        return false;//阻止浏览器的默认事件
    }
</script>
<a href="http://www.baidu.com" onclick="return f1()">百度</a>

//第三种写法
<a href="http://www.baidu.com" id="ak">百度</a>
<script>
	document.getElementById("ak").onclick=function() {
        alert("被点了");
        return false;
    };
</script>
案例三：点击小图显示大图
<a href="images/1.jpg" id="ak"><img src="images/1-small.jpg" alt=""></a>
<img src="" alt="" id="big">
<script>
	my$("ak").onclick = function() {
        my$("big").src = this.href;
        return false;//不会跳转到新的页面
    };
</script>
案例四：列表高亮显示
<head>
    <style>
        ul{
            list-style-type: none;//去掉列表前面的点
            cursor: pointer;//鼠标放上去是小手样式
        }
    </style>
</head>
<body>
    <ul>
        <li>雪花</li>
        <li>百威</li>
        <li>青岛</li>
        <li>燕京</li>
        <li>乌苏</li>
    </ul>
    <script>
    	var list = document.getElementsByTagName("li");
        for(var i = 0;i<list.length;i++) {
            list[i].onmouseover = function() {
                this.style.backgroundColor="yellow";
            };
            list[i].onmouseout = function() {
                this.style.backgroundColor="";//恢复到这个标签默认的颜色
            };
        }
    </script>
</body>
案例五：二维码的显示和离开
<style>
    .erweima{
        
    }
    .hide{
        display:none;
    }
    .show{
        display:block;
    }
    
</style>
<div class="nodeSmall" id="node_small">
    <a href="#"></a>
    <div class="erweima hide" id="er">
    	<img src="images/1.jpg" alt="" />
    </div>
</div>
<script>
	var aObj = my$("node_small").getElementsByTagName("a")[0];
    aObj.onmouseover = function() {
        my$("er").className = "erweima show";
    };
    aObj.onmouseout = function() {
        my$("er").className = "erweima hide";
    }
</script>
//案例：根据类样式的名字获取元素
<p>this is a p</p>
<p class="cls">this is a p</p>
<span class="cls">this is a span</span><br />
<span>this is the second span</span><br />
<div class="cls">this is a div</div>
<div class="cls">this is the second div</div>
<input type="button" value="显示效果" id="btn" /> <br />
<script>
	my$("btn").onclick=function() {
        var objs = document.getElementsByClassName("cls");
        for(var i = 0;i<objs.length;i++) {
            objs[i].style.backgroundColor="red";
        }
    }

</script>
//案例 根据name属性获取元素
<input type="button" value="显示效果" id="btn" /><br />
<input type="text" value="您好" name="name1" /><br/>
<input type="text" value="您好" name="name2" /><br/>
<input type="text" value="您好" name="name1" /><br/>
<input type="text" value="您好" name="name1" /><br/>
<script>
	my$("btn").onclick=function() {
        var inputs=document.getElementsByName("name1");
        for(var i = 0;i<inputs.length;i++) {
            inputs[i].value="我很好";
        }
    }
</script>
//案例 其他的获取元素方式
<style>
    .cls{
        
    }
</style>
<input type="button" value="显示效果" id="btn" />
<p>这是一个p</p>
<p class="cls">这是一个p</p>
<span>这是一个span</span>
<span class="cls">这是一个span</span>
<script>
    //根据选择器的方式获取元素
	var btnObj = document.querySelector("#btn")
    btnObj.onclick = function() {
        alert("哈哈");
    };
    var objs = document.querySelectorAll(".cls");
    for(var i = 0;i<objs.length;i++) {
        objs[i].style.backgroundColor="green";
    }
</script>
//案例 模拟搜索框(获取/失去焦点事件)
<head>
    <style>
        input{
            color:gray; 	
        }
    </style>
</head>
<input type="text" value="请输入搜索内容" id="txt" />
<script>
    //获取焦点
	my$("txt").onfocus = function() {
        //console.log("有了");
        if(this.value=="请输入搜索内容"){
            this.value = "";
            this.style.color="black";
        }
    };
    //失去焦点
    my$("txt").onblur=function() {
        //console.log("没了");
        if(this.value=="") {
            this.value="请输入搜索内容";
            this.style.color="gray";
        }
        //下面写法好
        if(this.value.length==0) {
            this.value="请输入搜索内容";
            this.style.color="gray";
        }
    };
</script>
//案例 验证文本框密码长度
<input type="text" value="" id="txt" />
<script>
	my$("txt").onblur=function() {
        if(this.value.length>=6&&this.value.length<=10) {
            this.style.backgroundColor="red";
        }else{
            this.style.backgroundColor="green";
        }
    };
</script>
//案例 封装innerText和textContent
<input type="button" value="设置值" id="btn" />
<div id="dv">lalal </div>
<script>
    //如果这个属性在浏览器中不支持，那么这个属性的类型是undefined
    //即判断这个属性的类型是不是undefined，就知道浏览器是否支持
    //兼容代码
    
    //设置任意的标签中间的任意文本内容
    function setInnerText(element, text){
        //判断浏览器是否支持这个属性
        if(typeof element.textContent=="undefined") {
            //说明不支持
            element.innerText=text;
        }else {
            //支持这个属性
            element.textContent = text;
        }
    }
    //获取任意的标签中间的文本内容
    function getInnerText(element) {
        if(typeof element.textContent=="undefined") {
            return element.innertText;
        }
        else {
            return element.textContent;
        }
    }
    //测试上述封装的函数
    my$("btn").onclick = function() {
        //console.log(getInnerText(my$("dv")));
        setInnerText(my$("dv"),"ahahha");
    }
    //点击按钮设置div中的文本内容
	//my$("btn").onclick=function() {
        //设置标签中的文本内容，应该使用textContent属性
        //my$("dv").textContent="this is div 标签";//ie 8不支持
        //my$("dv").innerText="啊，这是div";//ie8 支持
    //};
</script>
//案例 innerText和innerHTML
<input type="button" value="显示效果" id="btn" />
<div id="dv">
哈哈
    <p>这是一个p</p>
</div>
<script>
    //使用innertText主要是设置文本的，设置标签内容，是没有标签的效果的。
    //使用innerHTML主要的作用是在标签中设置新的html标签内容（有标签效果）
    
    //总结：想要设置标签内容，使用innerHTML,想要设置文本内容，innerText或者textContent获取
    //innerHTML，推荐用innerHTML。
    
    //获取的情况
    //innerText可以获取标签中间的文本内容，但是标签中如果还有标签，那么里面的标签
    //的文本内容也能获取。---获取不到标签，文本可以获取
    //innerHTML才是真正的获取标签中间的所有内容。
	my$("btn").onclick = function() {
        my$("dv").innertText="哈哈";
        my$("dv").innertText="<p>这是一个p</p>";//显示不出html标签的效果
    	
        my$("dv").innerHTML="哈哈";
        my$("dv").innerHTML="<p>这是一个p</p>";//可以设置html标签效果
    
    };
    //获取
	my$("btn2").onclick=function() {
        console.log(my$("dv").innerText);
        console.log(my$("dv").innerHTML);
    }
</script>

//案例 自定义属性
<style>
    ul{
        list-style-type: none;
        cursor: pointer;
    }
</style>
<ul id="uu">
    <li score="20">数学成绩</li>
    <li score="30">语文成绩</li>
    <li score="40">英语成绩</li>
    <li score="50">地理成绩</li>
    <li score="60">政治成绩</li>
    <li score="70">化学成绩</li>
</ul>
<script>
    //在html标签中添加的自定义属性，如果想要获取这个属性的值，需要
    //使用getAttribute("自定义属性的名字")才能获取这个属性的值
	var list=document.getElementsByTagName("li");
    for(var i = 0;i<list.length;i++) {
        list[i].onclick=function() {
            //alert(this.score);//undefined
            alert(this.getAttribute("score"));
        };
    }
</script>
<script>
	//获取所有的li标签，然后为每个标签中动态的添加
    //自定义属性和值，点击的时候获取该标签的自定义属性的值
    var list=my$("uu").getElementsByTagName("li");
    for(var i = 0;i<list.length;i++){
        //list[i].score = (i+1)*10;//此方式，自定义属性在DOM对象上，不在标签中,f12看不到添加上了
        list[i].setAttribute("score",(i+1)*10);
        
        list[i].onclick=function() {
            alert(this.getAtttribute("score"));
        };
    }
</script>
//案例  移除自定义属性
<div id="dv" score="10" class="cls"></div>
<script>
	my$("btn").onclick=function() {
        my$("dv").removeAttribute("score");
        my$("dv").className="";//移除元素的类样式，值没有了，但是属性还在
        my$("dv").removeAttribute("class");//也可以移除元素自带的属性
    };
</script>
```

id和类样式取名尽量不要一样。

节点

```html
/*
文档：document
元素：页面中所有的标签--element， 标签==元素==对象
节点：页面中所有的内容(标签，属性，文本(文字，换行，空格，回车))，Node
根元素：html标签
标签才能作为父结点。
*/
节点的属性：可以使用标签元素点.出来，可以使用属性节点点.出来，文本节点点.出来
nodeType:节点的类型：1代表标签，2代表属性，3代表文本
nodeName：节点的名字：标签节点---大写的标签名字，属性节点---小写的属性名字
		文本节点----#text
nodeValue:节点的值：标签节点----null，属性节点----属性值，文本节点----文本内容
<div id="dv">
    <span>这是div中的第一个span标签</span>
    <p>这是div中的第二个元素，第一个p标签</p>
    <ul id="uu">
        <li>乔峰</li>
        <li>鹿茸</li>
        <li id="three">段誉</li>
        <li>卡卡西</li>
        <li>雏田</li>嘎嘎
    </ul>
</div>
<script>
	var ulObj = my$("uu");
    console.log(ulObj.parentNode);//div
    console.log(ulObj.parentNode.parentNode);//body
    console.log(ulObj.parentNode.parentNode.parentNode);//html
    console.log(ulObj.parentNode.parentNode.parentNode.parentNode);//#document
    console.log(ulObj.parentNode.parentNode.parentNode.parentNode.parentNode);//null
    
    console.log(ulObj.parentNode);//ul标签的父级节点
    console.log(ulObj.parentElement);//ul标签的父级元素
    
    console.log(ulObj.parentNode.nodeType);
    console.log(ulObj.parentNode.nodeName);
    console.log(ulObj.parentNode.nodeValue);
</script>
<script>
	var dvObj = document.getElementById("dv");
    //子节点
    console.log(dvObj.childNodes);//7个子节点(记得换行也属于) {text,span,text,p,text,ul#uu,text}
    //子元素
    console.log(dvObj.children);//3个子元素 {span,p,ul}
    
    //获取每个里面的子节点
    for(var i = 0;i<dvObj.childNodes.length;i++) {
        var node = dvObj.childNodes[i];
        console.log(node.nodeType+"===="+node.nodeName+"===="+node.nodeValue);
    }
    
    //获取的是属性节点
    var dvObj = document.getElementById("dv");
    var node = dvObj.getAttributeNode("id");
    console.log(node.nodeType+"===="+node.nodeName+"===="+node.nodeValue);//2   id   dv


	//12行代码：都是获取节点和元素的
    //ul
    var ulObj=document.getElementById("uu");
    //父级节点
    console.log(ulObj.parentNode);
    //父级元素
    console.log(ulObj.parentElement);
    //子节点
    console.log(ulObj.childNodes);
    //子元素
    console.log(ulObj.children);
    //第一个子节点
    console.log(ulObj.firstChild);//IE8中是第一个子元素
    //第一个子元素
    console.log(ulObj.firstElementChild);//IE8中不支持
    //最后一个子节点
    console.log(ulObj.lastChild);//IE8中是第一个子元素
    //最后一个子元素
    console.log(ulObj.lastElementChild);//IE8中不支持
    //某个元素的前一个兄弟节点
    console.log(my$("three").previousSibling);
    //某个元素的前一个兄弟元素
    console.log(my$("three").previousElementSibling);
    //某个元素的后一个兄弟节点
    console.log(my$("three").nextSibling);
    //某个元素的后一个兄弟元素
    console.log(my$("three").nextElementSibling);

</script>
//案例 切换背景图片
<div id="mask">
	<img src="images/1.jpg" alt="">//alt属性是图片加载不出来的时候用的
    <img src="images/2.jpg" alt="">
    <img src="images/3.jpg" alt="">
</div>
<script>
	var imgObjs=my$("mask").children;//获取的所有子元素
    //循环遍历所以img，注册点击事件
    for(var i = 0;i<imgObjs.length;i++){
        imgObjs[i].onclick=function() {
            document.body.style.backgroundImage="url("+this.src+")";
        };
    }
</script>

/*
元素创建-----为了提高用户的体验
元素创建的三种方式：
1. document.write("标签的代码及内容");
2. 对象.innerHTML="标签及代码";
3. document.createElement("标签的名字");
*/
//第一种元素创建方式
//document.write()创建元素，缺陷：如果是在页面加载完毕后，
//此时通过这种方式创建元素，那么页面上存在的所有内容全部被干掉
<input type="button" value="创建一个p" id="btn" />
<script>
	my$("btn").onclick=function() {
        document.write("<p>这是一个p</p>");//页面加载完毕后创建的
    };
    document.write("<p>这是一个p</p>");//页面加载时创建，则其他还有。
</script>

//第二种元素创建方式
<input type="button" value="创建一个p" id="btn" />
<div id="dv"></div>
<script>
	//点击按钮，在div中创建一个p标签
    my$("btn").onclick = function() {
        my$("dv").innerHTML = "<p>啦啦啦啦</p>";
    };
</script>

//案例 动态创建列表
<script>
	varr names=["杨过"，"郭靖","张无忌","张三丰","乔峰"];
    my$("btn").onclick = function() {
      var str="<ul style='list-style-type: none;cursor:pointer'>";
      for(var i = 0;i<names.length;i++){
          str += "<li>"+names[i]+"</li>";
      }
      str+="</ul>";
        my$("dv").innerHTML=str;
        
        //代码执行到这里，li已经有了
        var list = my$("dv").getElementsByTagName("li");
        for(var i = 0;i<list.length;i++) {
            list[i].onmouseover = function() {
                this.style.backgroundColor = "yellow";
            };
            list[i].onmouseout = function() {
                this.style.backgroundColor = "";
            };
        }
    };
</script>

//扩展 document.write可以嵌入外部的代码内容
<!DOCTYPE html>
<html lang="en">
<head>
    <style type=text/css> div{font-size:12px;font-family:arial}.baidu{font-size:14px;line-height:24px;font-family:arial} a,a:link{color:#0000cc;}
.baidu span{color:#6f6f6f;font-size:12px} a.more{color:#008000;}a.blk{color:#000;font-weight:bold;}		</style>
</head>
<body>
	<script language="JavaScript" type="text/JavaScript" src="http://news.baidu.com/ns?word=title%3A%BB%A5%C1%AA%CD%F8&tn=newsfcu&from=news&cl=2&rn=5&ct=0">
    </script>
    //新建一个记事本，然后文件->打开，然后文件名中输入上述地址，然后打开，就看到了代码。
</body>
    
//第三种元素创建方式
<input type="button" value="创建p" id="btn" />
<div id="dv"></div>
<script>
	//创建元素
	//document.createElement("标签名字");//返回一个对象
	//把元素追加到父级元素中
    my$("btn").onclick = function() {
        var pObj = document.createElement("p");
        pObj.innerText = "这是一个p";
        my$("dv").appendChild(pObj);//鼠标每点击一下可以一直追加
    }
</script>    
//案例动态创建列表
<input type="button" value="创建列表" id="btn" />
<div id="dv"></div>
<script>
	var kungfu = ["lal","sdfd","sfwe","sfwef"];
	
	my$("btn").onclick = function(){
        var ulObj = document.createElement("ul");
        my$("dv").appendChild(ulObj);
        for(var i = 0; i<kungfu.length;i++){
            var liObj = document.createElement("li");
            liObj.innerHTML = kungfu[i];
            ulObj.appendChild(liObj);
            liObj.onmouseover = mouseoverHandle;
            liObj.onmouseout = mouseoutHandle;
        }
    };
    
    function mouseoverHandle() {
    	this.style.backgroundColor = "red";
    }
    function mouseoutHandle() {
    	this.style.backgroundColor = "";
    }
    
</script>
//案例 元素相关的操作方法
<input type="button" value="显示效果" id="btn"/>
<input type="button" value="删除第一个元素" id="btn2"/>
<input type="button" value="删除所有元素" id="btn3"/>
<script>
	var i = 0;
	my$("btn").onclick = function(){
		i++;
		var obj = document.createElement("input");
		obj.type = "button";
		obj.value="按钮"+i;
		//my$("dv").appendChild(obj);//追加子元素
		//把新的子元素插入到第一个子元素的前面
		my$("dv").insertBefore(obj,my$("dv").firstElementChild);
		//my$("dv").replaceChild();
	};
	my$("btn2").onclick = function(){
		my$("dv").removeChild(my$("dv").firstElementChild);
	};
	my$("btn3").onclick  = function(){
		while(my$("dv").firstElementChild){
			my$("dv").removeChild(my$("dv").firstElementChild);
		}
	};
</script>
//案例 只创建一个元素
<script>
	my$("btn").onclick = function(){
        if(!my$("btn2")) {
            var obj = document.createElement("input");
            obj.type = "button";
            obj.value="按钮";
            obj.id="btn2";
            my$("dv").appendChild(obj);
            //my$("dv").removeChild(my$("btn2"));
        }
        
    };    
    
</script>

//案例 为同一个元素绑定多个事件
<input type="button" value="按钮" id="btn"/>
<script>
    /*
    1  对象.addEventListener("事件类型"，事件处理函数，true/false);ie8不支持
    2  对象.attachEvent("有on的事件类型"，事件处理函数);谷歌火狐不支持
    */
    
	//为按钮绑定点击事件
	//参数1:事件的类---事件的名字，没有on
	//参数2：事件处理函数----（命名函数或匿名函数）
	//参数3：布尔类型，false/true
    //为同一个元素绑定多个相同的事件，都会执行，不冲突
	my$("btn").addEventListener("click",function(){//该方法IE8不支持
		console.log("阿萨德发的说法");
	},false);
	my$("btn").addEventListener("click",function(){
		console.log("是的发生");
	},false);
	my$("btn").addEventListener("click",function(){
		console.log("asdf");
	},false);
    
    my$("btn").attachEvent("onclick",function(){
        console.log("alalla");
    });
</script>
    
/*绑定事件的区别
addEventListener中的this是当前绑定事件的对象
attachEvent中的this是window
*/
<input type="button" value="按钮" id="btn" />
<script>
	my$("btn").addEventListener("click",function(){
		console.log(this);//输出 <input type="button" value="按钮" id="btn" />
	},false);
	
	my$("btn").attachEvent("onclick",function(){
		console.log(this);//输出 Window
	})
</script>

/*解绑事件
注意:用什么方式绑定事件，就用对应的方式解绑事件

*/
<script>
	//解绑事件方法一
	my$("btn").onclick=function(){
		console.log("alala");
	};
	my$("btn2").onclick=function(){
		//解绑
		my$("btn").onclick=null;
	};
	
	//解绑事件方法二
	function f1(){
		console.log("第一个");
	}
	function f2(){
		console.log("第二个");
	}
	my$("btn").addEventListener("click",f1,false);//不能使用匿名函数，因为在解绑的时候不能用匿名，两个都是匿名的话对应不起来，解绑不了
	my$("btn").addEventListener("click",f2,false);
	
	//点击第二个按钮把第一个按钮的第一个点击事件解绑
	my$("btn2").onclick=function(){
		//解绑事件的时候，需要在绑定事件的时候，使用命名函数
		my$("btn").removeEventListener("click",f1,false);
	};
	
	//解绑事件方法三
	function f1(){
		console.log("第一个");
	}
	function f2(){
		console.log("第二个");
	}
	my$("btn").attachEvent("onclick",f1);
	my$("btn").attachEvent("onclick",f2);
	
	my$("btn2").onclick=function(){
		my$("btn").detachEvent("onclick",f1);//解绑
	};
</script>

<script>
//绑定/解绑事件兼容代码
function addEventListener(element,type,fn){
	if(element.addEventListener){
		element.addEventListener(type, fn, false);
	}else if(element.attachEvent){
		element.attachEvent("on"+type, fn);
	}else{
		element["on"+type]=fn;
	}
}

function removeEventListener(element,type,fnName){
	if(element.removeEventListener){
		element.addEventListener(type,fnName,false);
	}else if(element.detachEvent){
		element.attachEvent("on"+type,fnName);
	}else{
		element["on"+type]=null;
	}
}
    //测试
    addEventListener(my$("btn1"),"click",f1);
    addEventListener(my$("btn1"),"click",f2);
    
    my$("btn2").onclick=function(){
        removeEventListener(my$("btn1"),"click",f1);
    };
</script>
```

事件冒泡

```html
//事件冒泡：多个元素嵌套，有层次关系，这些元素都注册了相同的事件，如果里面的元素的事件触发了，外面的元素的该事件自动的触发了。比如p的点击事件触发了，div的点击事件也会自动触发。
//其实div和p的关系是，p在div的上面，俯视图的话，看着像是div包含了p
<div>
    <p></p>
</div>
<div id="dv1">
    <div id="dv2">
        <div id="dv3"></div>
    </div>
</div>
//事件冒泡：点dv3后，dv1,dv2也触发了
<script>
	my$("dv1").onclick = function(){
        console.log(this.id);
    };
    my$("dv2").onclick = function(){
        console.log(this.id);
    };
    my$("dv3").onclick = function(/*e*/){
        console.log(this.id);
        //console.log(arguments.length);//1  其实有一个参数，是一个对象(事件处理参数对象)
    	//console.log(e);
    };
</script>
/*
阻止事件冒泡：点dv3后，dv1,dv2不触发
window.event.cancelBubble=true;//火狐不支持
e.stopPropagation();//IE不支持

my$("dv2").onclick = function(){
        console.log(this.id);
		window.event.cancelBubble=true;
    };
my$("dv3").onclick = function(e){//IE8没有e这个参数
        console.log(this.id);
		e.stopPropagation();
    };
*/
<script>
/*
事件三个阶段
	1.事件捕获阶段：从外向里（从外面的房间一直进入到里面的房间，进行捕获）
	2.事件目标阶段：选中的那个
	3.事件冒泡阶段:从里向外
*/
	var objs = [my$("dv3"), my$("dv2"), my$("dv1")];
    //遍历注册事件
    objs.forEach(function (ele){
       //为每个元素绑定事件
        ele.addEventListener("click",function(e){
            console.log(this.id+"=====>"+e.eventPhase);
        },true);//false是冒泡阶段，true是捕获阶段
    });
    //e.eventPhase:如果这个属性的值是1，则是捕获阶段，2代表目标阶段，3代表冒泡阶段
	//一般默认是冒泡阶段，很少用捕获阶段
</script>

//为同一个元素绑定多个不同的事件，指向相同的事件处理函数。
<input type="button" value="显示效果" id="btn" />
<script>
	my$("btn").onclick = f1;
    my$("btn").onmouseover = f1;
    my$("btn").onmouseout = f1;
    function f1(e){
        switch(e.type){
            case "click":
                alert("lala");
                break;
            case "mouseover":
                this.style.backgroundColor="red";
                break;
            case "mouseout":
                this.style.backgroundColor = "green";
                break;
        }
    }
    
    //my$("btn").onmouseover = function(e){
    //    console.log(e);//e里面有个参数type，表示事件名称
    //}
</script>
```

BOM

```html
浏览器中顶级对象：window
页面中顶级对象：document
页面中所有内容都是属于浏览器的，即都是属于window的
<script>
	var num = 100;
    console.log(window.num);//等价于console.log(num);
    function f1(){
        console.log("ahaha");
    }
    window.f1();
    //因为页面中的所有内容都是window的，所有window是可以省略的
    
    //window有个特殊的属性 name
    console.log(window.name);//输出空
    
    //top和window输出一样，top和window是一样的
    console.log(top);
    console.log(window);
</script>

//系统的对话框
<script>
	window.alert("hah");
    window.prompt("input your account");
    var res = window.confirm("退出吗？");//点确定或取消
    console.log(res);//trur/false
</script>

/*
页面加载的事件
*/
<head>
    <script>
    	//页面加载的时候，按钮还没出现，页面没有加载完毕
        
        //页面加载完毕了，再获取按钮
        //只要页面加载完毕，这个事件就会出发（页面加载包括页面中所有的内容，标签
        //属性，文本，包括外部引入js文件）
        window.onload = function(){//可以写成onload，window可以省略
            document.getElementById("btn").onclick=function(){
                alert("您好");
            };
        };
        //页面关闭后才触发的事件
        window.onunload = function(){
            alert("hahah");
        };
        //页面关闭之前触发。
        window.onbeforeunload = function(){
            alert("haha");
        };
    </script>
</head>
<body>
<input type="button" value="按钮" id="btn"/>
</body>
```

location对象

```html
<script>
console.log(window.location);
console.log(window.location.hash);//地址栏上#号及后面的内容
console.log(window.location.host);//主机名及端口号
console.log(window.location.hostname);//主机名
console.log(window.location.pathname);//文件的路径
console.log(window.location.port);//端口号
console.log(window.location.protocol);//协议
console.log(window.location.search);//搜索的内容
    onload = function(){
        document.getElementById("btn").onclick=function(){
            //设置跳转的页面地址,两种方式相同
            location.href="http://www.jd.com";//属性
            location.assign("http://www.jd.com");//方法
            location.reload();//重新加载，刷新
            location.replace("http://www.jd.com");//不同于href和assign，没有历史记录，不能后退
        };
    };
</script>
<input type = "button" value="显示效果" id="btn" />

```

history对象

```html
//第一个页面
<input type="button" value="跳过去" id="btn1" />
<input type="button" value="前进" id="btn2" />
<script>
	//跳转的
    my$("btn1").onclick=function(){
        window.location.href="test.html";
    };
    //前进
    my$("btn2").onclick=function(){
        window.history.forward();
    };
</script>

//第二个页面
<script>
    //后退
	my$("btn").onclick=function(){
        window.history.back();
    };
</script>
```

navigator对象

```html
<script>
console.log(window.navigator.userAgent);//浏览器版本
console.log(window.navigator.platform);//判断浏览器所在的系统平台类型
</script>
```

定时器

```html
<script>
BOM中有两个定时器
//参数1：函数
//参数2：时间---单位毫秒
//执行过程:页面加载完毕后，过了几毫秒，执行一次函数的代码，过了几毫秒再执行函数....
//返回值就是定时器的id值
var timeId = setInterval(function(){
	alert("hello");//断言
},1000);

document.getElementById("btn").onclick = function(){
    //点击按钮，停止计时器
    //参数：要清理的定时器的id的值
    window.clearInterval(timeId);
};
</script>

//案例 亮晶晶
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
    <title>test</title>
    <style>
        div{
            width:600px;
            height:600px;
            border:2px solid yellow;
            background-color:black;
            position:relative;
        }
        span{
            font-size:30px;
            color:yellow;
            position:absolute;
        }
    </style>
</head>
<input type="button" value="亮起来" id="btn"/>
<div id="dv"></div>
<script>
	document.getElementById("btn").onclick = function(){
        setInterval(function(){
            document.getElementById("dv").innerHTML="<span>☆</span>";
            
            var x = parseInt(Math.random()*600+1);
            var y = parseInt(Math.random()*600+1);
            document.getElementById("dv").firstElementChild.style.left=x+"px";
            document.getElementById("dv").firstElementChild.style.top=y+"px";
        },10);
    };
</script>
    
/*
    第二个定时器-----一次性的定时器
    参数1：函数
    参数2：时间
    返回值：该定时器的id
*/
    <script>
        //一次性定时器，只执行一次
    	var timeId = window.setTimeout(function(){
            alert("您好");
        },1000);
        //点击这个按钮，停止这个一次性的定时器（其实是清理它占用的空间，因为它只执行一次，会自动停止）
        document.getElementById("btn").onclick=function(){
            clearTimeout(timeId);
        }
    </script>

//案例 协议按钮禁用
<body>
    <textarea name="texta" id="" cols="30" rows="10">
        协议内容sadfajsdfasdfas。
    </textarea>
    <input type="button" value="请仔细阅读协议(5)" id="btn" disabled = "disabled" />
    <script>
    	var time=5;
        var timeId = setInterval(function(){
            time--;
            my$("btn").value="请仔细阅读协议("+time+")";
            if(time<=0){
                clearInterval(timeId);
                my$("btn").disabled=false;
                my$("btn").value = "同意";
            }
        },1000);
    </script>
</body>
```

如果样式的代码是在**style的标签**中设置的，那么外面是获取不到的。

如果样式的代码是在**style的属性**中设置的，那么外面可以获取到。

```html
案例 移动元素
<head>
    <style>
        div{
            width: 200px;
            heigtht: 200px;
            background-color:red;
            position:absolute;
        }
    </style>
</head>
<input type="button" value="移动到800px" id="btn2" />
<div id="dv"></div>
<script>
	my$("btn1").onclick=function(){
        animate(my$("dv"), 400);
    }; 
    
    my$("btn2").onclick=function(){
        animate(my$("dv"), 800);
    }; 
    function animate(element, target){
        clearInterval(element.timeId);
        element.timeId = setInterval(function(){
         //获取div的当前位置
         var current = element.offsetLeft;//数字类型，没有px
         //div每次移动多少像素
            var step = 10;
            step = current<target?step:-step;
            current += step;
            if(Math.abs(target-current)>Math.abs(step)){
                element.style.left = current+"px";
            }else {
                clearInterval(element.timeId);
                element.style.left=target+"px";
            }
        },20);
    }
</script>
```

offset系列

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>title</title>
    <style>
        *{
            margin: 0;
            padding:0;
        }
        input{
            top:250px;
            position:absolute;
        }
        #dv1{
            width:200px;
            height:150px;
            background-color:red;
            margin-left:100px;
            padding-left:50px;
            border:20px solid yellow;
        }
         #dv2{
            width:200px;
            height:50px;
            background-color:green;
            margin-left:30px;
            padding-left:100px;
            border:20px solid pink;
        }
    </style>
    <script>
        //三个大的系列
        /*
        三组属性
        1. offset系列中的属性

        */
	</script>
</head>
<body>
    <div id="dv1">
        <div id="dv2"></div>
    </div>
<input type="button" value="显示效果" id="btn" />
    <script>
    	my$("btn").onclick = function(){
            //在style标签中设置的样式属性获取不到
            //style属性中设置的样式属性是可以获取到的
            //获取元素的方式，下面的方式废了
            //console.log(my$("dv1").style.width);
            //console.log(my$("dv1").style.height);
            
            //以后获取元素的宽和高，应该使用offset系列来获取
            /*
            offsetWidth:获取元素的宽(有边框)
            offsetHeight:获取元素的高(有边框)
            offsetLeft:获取元素距离左边位置的值
            offsetTop:获取元素距离上面位置的值
            */
            console.log(my$("dv1").offsetWidth);
            console.log(my$("dv1").offsetHeight);
            
            console.log(my$("dv1").offsetLeft);
            console.log(my$("dv1").offsetTop);
            
            //没有脱离文档流：
            /*
            	offsetLeft= 父级元素margin+父级元素padding+父级元素border+自己的margin
            	
            	脱离文档流:
            	offsetLeft= 主要是自己的left和自己的margin
            */
            console.log(my$("dv2").offsetLeft);
        };
    </script>
</body>
</html>

//通过document获取元素
<script>
    //获取body
	console.log(document.body);//获取的是元素--标签
    //获取title
    console.log(document.title);//获取的是title标签中的值
    document.title="haha";//修改
    //获取html
    console.log(document.documentElement);
</script>

//案例：图片跟着鼠标飞
<style>
    img{
        position:absolute;
    }
</style>
<img src="images/bird.png" alt="" id="im">
<script>
	document.onmousemove = function(e){
        //鼠标的横纵坐标
        my$("im").style.left = e.clientX + "px";
        my$("im").style.top = e.clientY + "px";
    };
</script>
```

scroll系列

```html
<script>
	my$("btn").onclick=function(){
        console.log(my$("dv").scrollWidth);//元素中内容的实际宽度(没有边框)(大小至少是元素的宽)，如果没有内容就是元素的宽
        console.log(my$("dv").scrollHeight);//元素中内容的实际高度(没有边框)(大小至少是元素的高),如果没有内容就是元素的高
        console.log(my$("dv").scrollTop);//向上卷曲出去的距离
        console.log(my$("dv").scrollLeft);//向左卷曲出去的距离
    }
    
    //div的滚动事件
    my$("dv").onscroll=function(){
        console.log(this.scrollTop);
    };
    
    //封装getScroll函数
    //获取浏览器向上或向左卷曲出去的距离
    function getScroll1(){
        var obj = {};
        var top1 = window.pageYOffset || document.documentElement.scrollTop
    || document.body.scrollTop||0;
    var left = window.pageXOffset || document.documentElement.scrollLeft
    || document.body.scrollLeft;
        obj.left=left;
        obj.top=top1;
        return obj;
    }
       function getScroll2(){
        var obj = {};
        obj.left = window.pageYOffset || document.documentElement.scrollTop
    || document.body.scrollTop||0;
    	obj.top = window.pageXOffset || document.documentElement.scrollLeft
    || document.body.scrollLeft;
        return obj;
    }
        function getScroll3(){
        var obj = {
        left : window.pageYOffset || document.documentElement.scrollTop
    || document.body.scrollTop||0,
    	top : window.pageXOffset || document.documentElement.scrollLeft
    || document.body.scrollLeft
        };
        return obj;
    }
    //封装最终版本
      function getScroll4(){
        return {
        left : window.pageYOffset || document.documentElement.scrollTop
    || document.body.scrollTop||0,//0是该浏览器三种方式都不支持
    	top : window.pageXOffset || document.documentElement.scrollLeft
    || document.body.scrollLeft||0
        };
    }
    //测试，浏览器的滚动事件
    window.onscroll=function(){
        console.log(getScroll4().top);
    };
    
    //向上卷曲出去的距离
    var top1 = window.pageYOffset || document.documentElement.scrollTop
    || document.body.scrollTop||0;//兼容代码，不同浏览器可能获取方式不一样
    //向左
    var left = window.pageXOffset || document.documentElement.scrollLeft
    || document.body.scrollLeft;
</script>

//案例 固定导航栏
<div class="top" id="topPart"></div>
<div class="nav" id="navBar"></div>
<div class="main" id="mainPart"></div>
<script>
	
    //滚动事件
    window.onscroll=function(){
        //向上卷曲出去的距离和最上面的div的高度对比
        if(getScroll().top>=my$("topPart").offsetHeight){
            my$("navBar").style.position = "fixed";
            my$("navBar").style.top = 0;
            my$("mainPart").style.marginTop=my$("navBar").offsetHeight+"px";
        }else{
        	my$("navBar").className="nav";
        	my$("mainPart").style.marginTop="10px";
        }
    };
    
</script>
```

变速动画封装

```html
<script>
function animate(element, target){
	clearInterval(element.timeId);
	element.timeId = setInterval(function(){
        //获取元素的当前位置
        var current = element.offsetLeft;
        //移动步数
        var step = (target-current)/10;
        step = step>0?Math.ceil(step):Math.floor(step);
        current += step;
        element.style.left = current + "px";
        if(current==target){
            clearInterval(element.timeId);
        }
        //测试代码
        console.log("目标位置:"+target+"，当前位置:"+current+",每次移动步数,"+step);
    },20);
}
</script>
```

获取元素计算后的样式属性值

```html
<style>
    div{
        width:200px;
        height:100px;
        background-color:purple;
        left:100px;
        //position:absolute;
    }
</style>
<input type="button" value="显示效果" id="btn" />
<div id="dv"></div>
<script>
	my$("btn").onclick = function(){
        //获取元素距离左边位置的值
        //console.log(my$("dv").offsetLeft);//没有position:absolute的话获取不了
        console.log(window.getComputedStyle(my$("dv"),null).left);//ie8不支持  输出100px
        console.log(window.getComputedStyle(my$("dv"),null)["left"]);
        
        console.log(my$("dv").currentStyle.left);//谷歌火狐不支持
    }
    //封装
    function getStyle(element,attr){
        return window.getComputedStyle?window.getComputedStyle(element,null)[attr]:
        element.currentStyle[attr];
    }
    //测试
    my$("btn").onclick=function(){
        console.log(getStyle(my$("dv"),"left"));
    };
</script>
```

封装缓动动画函数增加任意多个属性+回调函数

```html
<script>
function animate(element,json,fn){
    clearInterval(element.timeId);
    element.timeId=setInterval(function(){
        var flag = true;//默认，假设全部到达目标
        for(var attr in json){
            //获取元素这个属性的当前的值
            var current = parseInt(getStyle(element,attr));
            //当前的属性对应的目标值
            var target=json[attr];
            //移动的步数
            var step=(target-current)/10;
            step = step>0?Math.ceil(step):Math.floor(step);
            current+=step;
            element.style[attr]  = current+"px";
            if(current!=target){
                flag=false;
            }
        }
        if(flag){
            clearInterval(element.timeId);
            if(fn){
                fn();
            }
        }
        //测试
        console.log("目标:"+target+"，当前:"+current+",每次的移动步数:"+step);
    },20);
}
    my$("btn1").onclick=function(){
        var json1 = {"width":400,"height":500,"left":500,"top":80};
        animate(my$("dv",json1,function(){
            var json2 = {"width":40,"height":50,"left":50,"top":400};
        });
    };
</script>
```

当一个函数作为参数使用时，这个函数就是回调函数.

```html
<a href="地址"></a>
<a href="#name"></a>
<a href="javascript:void(0);"></a>//留给程序员写的，现在什么也不做
```

client系列：可视区域

```html
clientWidth:可视区域的宽（没有边框），边框内部的宽度
clientWidth:可视区域的高（没有边框），边框内部的高度
clientLeft:左边边框的宽度
clientTop:上边边框的高度
<style>
    div{
        width:200px;
        height:210px;
        border:20px solid red;
        border-left-width:50px;
        
    }
</style>
<div id="dv"></div>
<script>
	console.log(my$("dv").clientWidth);
    console.log(my$("dv").clientHeight);
    console.log(my$("dv").clientLeft);//50px
    console.log(my$("dv").clientTop);
</script>
```

案例：图片跟着鼠标飞

```html
<img src="images/tianshi.gif" alt="" id="im">
<script>
//通过arguments.length，可以得出：事件处理函数中实际上是有一个参数的，这个参数和事件有关系，是一个对象->事件参数对象
    //谷歌和火狐中都有这个事件参数对象，ie8中没有
    //事件参数对象:e-----在IE8中用window.event来代替
    document.onmousemove = function(e){
        console.log(arguments[0]);
        console.log(e);
    };
    
    document.onmousemove = function(e){
        my$("im").style.left = e.clientX+"px";
        my$("im").style.top = e.clientY+"px";
    };
    document.onmousemove = function(){//ie 8
        my$("im").style.left = window.event.clientX+"px";
        my$("im").style.top = window.event.clientY+"px";
    };
    //整合兼容代码
    document.onmousemove = function(e){//滚动条往下改代码就出问题
        e = window.event || e;
        //可视区域的横坐标
        //可视区域的纵坐标
        my$("im").style.left = e.clientX+"px";
        my$("im").style.top = e.clientY+"px";
    }
    
    document.onmousemove = function(e){
        //相对于页面顶部的坐标
          my$("im").style.left = e.pageX+"px";
          my$("im").style.top = e.pageY + "px";
          
        //pageX和pageY在谷歌和火狐可以使用，ie8不能用
        //my$("im").style.left = window.event.pageX+"px";
        //my$("im").style.top = window.event.pageY+"px";
    };
    
    //最终思路
    function getScroll(){
        return {
            left:window.pageXOffset || document.body.scrollLeft || 
            document.documentElement.scrollLeft||0,
            top:window.pageYOffset||document.body.scrollTop||document
            .documentElement.scrollTop||0
        }
    }
    //可视区域横坐标+向左卷曲出去的横坐标
    my$("im").style.left = window.event.clientX+getScroll().left+"px";
    //可视区域的纵坐标+向上卷曲出去的纵坐标
     my$("im").style.top = window.event.clientY+getScroll().top+"px";
    
    //最终版
    //把代码封装在一个函数
    
    //把代码放在一个对象中
    var evt = {
      //window.event和事件参数对象e的兼容
        getEvent:function(evt){
            return window.event||evt;
        }
        //可视区域的横坐标的兼容代码
        getClientX:function(evt){
            return this.getEvent(evt).clientX;
        },
        //可视区域的纵坐标的兼容代码
        getClientY:function(evt){
            return this.getEvent(evt).clientY;
        },
        //页面向左卷曲出去的横坐标
        getScrollLeft:function(){
            return window.pageXOffset || document.body.scrollLeft || 
            document.documentElement.scrollLeft||0;
        },
    	//页面向上卷曲出去的横坐标
    	getScrollTop:function(){
            return window.pageYOffset||document.body.scrollTop||document
            .documentElement.scrollTop||0;
        },
        //相对于页面的横坐标（pageX或者clientX+scrollLeft）
        getPageX:function(evt){
            return this.getEvent(evt).pageX?this.getEvent(evt).pageX:this.getClientX(evt)+this.getScrollLeft();
            
        },
        //相对于页面的纵坐标（pageY或者clientY+scrollTop）
    	getPageY:function(evt){
            return this.getEvent(evt).pageY?this.getEvent(evt).pageY:this.getClientY(evt)+this.getScrollTop();
        }
    
    };
    document.onmousemove = function(e){
        //my$("im").style.left = evt.getEvent(e).clientX+"px";
        //my$("im").style.top = evt.getEvent(e).clientY+"px";
        
        //my$("im").style.left  = evt.getClientX(e)+"px";
        //my$("im").style.top = evt.getClientY(e) + "px";
        
        my$("im").style.left = evt.getPageX(e)+"px";
        my$("im").style.top = evt.getPageY(e)+"px";
    };
</script>
```

